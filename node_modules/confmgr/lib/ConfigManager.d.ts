import { ConfigSpecs, ConfigItem, PrintOptions, ModuleDictionnary, Module, ConfigObject } from './types/types';
import { Key, ConfigValue } from './types/baseTypes';
/**
 * The ConfigManager class is where everything happens.
 *
 * The ConfigManager allows you loading your config specs definition,
 * it also loads your actual config and lets you access it.
 */
export declare class ConfigManager {
    private static instance;
    private config;
    private specs;
    /**
     * The constructor of ConfigManager is private and is called only
     * by GetInstance to ensure it works as singleton.
     * @param specs
     */
    private constructor();
    /**
     * Load specs from a YAML file
     * @param file Path of the YAML file
     */
    static loadSpecsFromYaml(file: string): ConfigSpecs;
    /**
     * ConfigManager is a singleton.
     * @param specs The config specs the ConfigManager will rely on. It can be a ConfigSpecs object or the path of a file.
     * In that case, the file can be either a YAML file or a JSON file.
     */
    static getInstance(specs?: ConfigSpecs | string): ConfigManager;
    /**
     * You should not use this function. It is there only for testing.
     */
    static clearInstance(): void;
    /**
     * This function converts a string to a boolean. It ignores the case and
     * support also values such as 0 and 1, yes and no.
     * @param s String to convert
     */
    private static stringToBoolean;
    getConfig(): ConfigObject;
    /**
     * This retrieves the config and fills defaults.
     * Additionnaly, the config object you get is decorated with a few helper fonctions
     * such as Print, Validate, etc... to help you easily use your config
     */
    buildConfig(): ConfigObject;
    getSpecs(): ModuleDictionnary;
    /**
     * This function defines what '.env' file will be loaded.
     * By default, '.env' will be used.
     * However, if you pass NODE_ENV=abc, the loaded file will
     * be .env.abc
     */
    private static getEnvFile;
    /** You likely will never have to use this function which
     * is mostly use for the tests. If you don't know, do NOT call
     * this function, it would take time and likely do nothing
     * interesting for you.
     */
    refresh(): void;
    /** Does not touch the ENV but rebuild the config.
     * This is useful if you know that the ENV changed
     */
    rebuild(): void;
    /** Calling this function will get an instance of the Config and attach it
     * to the global scope.
     */
    static loadToGlobal(): void;
    private static isregExpWithAttributes;
    /**
     * This is the actual function performing the validation of a given field according to the spcs
     * @param specs The specs
     */
    private validaFieldsSpecs;
    getFieldSpecs(module: Module, key: string): ConfigItem;
    /**
     * Validate a single field.
     * @param key Key of the field
     */
    ValidateField(module: Module, key: string): boolean;
    /** Validate the config and return wheather it is valid or not */
    Validate(): boolean;
    /** Check whether the module mod is part of ours specs */
    private isModuleValid;
    /** Check wether the key is valid. We assume here that the module does exist */
    private isKeyValid;
    /**
     * This Getter is the safest way to access your configuration values as it will throw errors in case you try access an invalid module/key
     * @param mod
     * @param key
     */
    Get(mod: Module, key: Key): ConfigValue;
    private printItemColor;
    private printItemNoColor;
    /**
     * Display the current ENV using either the logger you provide or console.log by default.
     */
    Print(opt: PrintOptions): void;
    GenEnv(): string[];
}
