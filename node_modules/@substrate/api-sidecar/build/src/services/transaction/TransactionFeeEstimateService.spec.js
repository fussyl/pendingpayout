"use strict";
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
Object.defineProperty(exports, "__esModule", { value: true });
const sanitizeNumbers_1 = require("../../sanitize/sanitizeNumbers");
const mock_1 = require("../test-helpers/mock");
const invalidResponse = require("../test-helpers/responses/transaction/feeEstimateInvalid.json");
const validResponse = require("../test-helpers/responses/transaction/feeEstimateValid.json");
const TransactionFeeEstimateService_1 = require("./TransactionFeeEstimateService");
const transactionFeeEstimateService = new TransactionFeeEstimateService_1.TransactionFeeEstimateService(mock_1.mockApi);
describe('TransactionFeeEstimateService', () => {
    describe('fetchTransactionFeeEstimate', () => {
        it('works with a valid a transaction', async () => {
            expect(sanitizeNumbers_1.sanitizeNumbers(await transactionFeeEstimateService.fetchTransactionFeeEstimate(mock_1.blockHash789629, mock_1.balancesTransferValid))).toStrictEqual(validResponse);
        });
        it('catches ApiPromise throws and then throws the correct error format', async () => {
            const err = new Error('2: Unable to query dispatch info.: Invalid transaction version');
            err.stack =
                'Error: 2: Unable to query dispatch info.: Invalid transaction version\n  ... this is a unit test mock';
            mock_1.mockApi.rpc.payment.queryInfo = () => Promise.resolve().then(() => {
                throw err;
            });
            await expect(transactionFeeEstimateService.fetchTransactionFeeEstimate(mock_1.blockHash789629, mock_1.balancesTransferInvalid)).rejects.toStrictEqual(invalidResponse);
            mock_1.mockApi.rpc.payment.queryInfo = mock_1.queryInfoBalancesTransfer;
        });
    });
});
//# sourceMappingURL=TransactionFeeEstimateService.spec.js.map